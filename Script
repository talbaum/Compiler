utop
#use "tag-parser.ml";;
open Tag_Parser;;
test "(define x 1)";;
-------------------------------
(let ((v1 b1)(v2 b2)) c1 c2 c3)

(* ------------------------------ shuli i love you ---------------------------------------------*)


(* -------------------------------------- cond ----------------------------------------------------------*)

and rib1_cond_tag_parser ribs = 
rib1_cond_tag_parser ribs
(*|->rib2_cond_tag_parser ribs
|->rib3_cond_tag_parser ribs
|_->raise X_syntax_error)*)

(*
and build_rib2 exp_k exp_f=
Pair (Symbol "let",Pair (Pair(   (Pair(Symbol("value"), exp_k))  ,Pair(Symbol("f"), Pair(Symbol("lambda"), Pair(Nil, exp_f)))), Pair(Symbol("if"), Pair(Symbol("value"), Applic(Symbol("value"),Symbol("f"))))))
*)

and  cond_tag_parser rib =
(match rib with
(*|Pair(Pair(exp_k,Pair(Symbol("=>"),exp_f)), Nil)->(tag_parse (build_rib2))
|Pair(Pair(exp_k,Pair(Symbol("=>"),exp_f)), rest)->tag_parse (Pair(Pair(Pair (Symbol "let",Pair (Pair(Pair(Symbol("value"),exp_k),Pair(Symbol("f"),Pair(Symbol("lambda"), Pair(Nil, exp_f))),Pair(Symbol("rest"),Pair(Symbol("lambda"), Pair(Nil, rest))))))),Pair(Symbol("if"), Pair(Symbol("value"), Pair(Symbol("f"), Pair(Symbol("rest"), Nil))))))
*)|Pair(Pair(Symbol("else"),seq),rest)->tag_parse (Pair(Symbol("begin"),seq))
|Pair(Pair(test,seq), Nil)-> tag_parse(Pair(Symbol("if"), Pair(test, Pair((Pair(Symbol("begin"), seq)), Nil))))
|Pair(Pair(test,seq), rest)-> tag_parse (Pair(Symbol("if"), Pair(test, Pair(Pair(Symbol("begin"),seq), (Pair((Pair(Symbol("cond"),rest)),  Nil))))))
|_->raise X_syntax_error)


(*--------------------------- seq --------------------------------------------- *)
and seq_tag_parser exprs = 
(match exprs with
    |Nil->Const(Void)
    |Pair(Symbol(x) as chino ,Nil)->tag_parse chino
    |_->Seq(map_tag_parse exprs))











Pair (Symbol "let",
 Pair
  (Pair (Pair (Symbol "v1", Pair (Symbol "b1", Nil)),
    Pair (Pair (Symbol "v2", Pair (Symbol "b2", Nil)), Nil)),
  Pair (Symbol "c1", Pair (Symbol "c2", Pair (Symbol "c3", Nil)))))
-----------------------------------------------------------------------

and handle_let_star args body  = match args with
|Nil -> tag_parse (Pair (Symbol "let",Pair (Nil, body)))
|Pair(Pair(single_var,single_val) as single ,Nil) -> tag_parse (Pair (Symbol "let",Pair (single, body)))
|Pair(Pair(car,cdr) as args,other_pairs) ->  
tag_parse (
    Pair (Symbol "let",Pair (args, Pair(Pair((Symbol "let*",Pair (other_pairs, body))),Nil))))
| _ -> raise X_syntax_error











above pattern matching:

let without_last_arg list = 
  let reversedList= List.rev list in
  let no_first_arg = List.tl reversedList in
  List.rev no_first_arg


at pattern matching:

|Pair (Symbol "let",Pair (Nil, body)) -> handle_let_no_args body
|Pair (Symbol "let",Pair (args, body)) -> handle_let args body
|Pair (Symbol "let*",Pair (args, body)) -> handle_let_star args body

below pattern matching::
(* ------------------------------- let star-------------------------------------*)

and handle_let_star args body  = match args with
|Nil -> tag_parse (Pair (Symbol "let",Pair (Nil, body)))
|Pair(single,Nil) -> tag_parse (Pair (Symbol "let",Pair (single, body)))
|Pair(car,cdr) ->  tag_parse (Pair(Pair (Symbol "let",Pair (car, body)), Pair (Symbol "let*",Pair (cdr, body))))
| _ -> raise X_syntax_error

(* ------------------------------- let -------------------------------------*)

and create_arglist ribs = match ribs with
|Pair(Pair (arg,value),Nil) ->  arg
|Pair(Pair(arg,value),next_ribs) -> (Pair(arg, (create_arglist next_ribs))) 
|_ -> raise X_syntax_error

and create_valueslist ribs = match ribs with
|Pair(Pair(arg,Pair(value,Nil)),Nil) -> Pair(value, Nil)
|Pair(Pair(arg,Pair(value,Nil)),next_ribs)  ->  Pair(value , create_valueslist next_ribs)
|_ -> raise X_syntax_error

and handle_let args body  =
 macro_extension_let body (create_arglist  args) (create_valueslist args )

and handle_let_no_args body  = 
macro_extension_let body Nil Nil


and macro_extension_let body arglist valuesList =  
(*| Pair(rib, ribs) -> tag_parse ( Pair(Pair(Symbol("lambda"), Pair((makeVariablesList args), body)), (makeValuesList args)) )*)
let parsed_lambda = tag_parse (Pair(Symbol("lambda"), (Pair(arglist, body))))  in
        Applic(parsed_lambda, map_tag_parse valuesList) 

and lambda_tag_parser args body= 
(match args with 
    | Nil -> LambdaSimple ([],(needBegin body))
    |Symbol(vs) -> LambdaOpt([], vs ,( needBegin body))
    | Pair(car,cdr) -> let converted_args = convert_to_string_list args in 
                      if (is_not_duplicated_args converted_args) then
                              if(is_improper_list args)
                              then LambdaOpt(without_last_arg(converted_args), find_last_element(converted_args),( needBegin body))
                              else LambdaSimple(converted_args,( needBegin body))
                      else raise X_syntax_error
    |_ -> raise X_syntax_error) 


