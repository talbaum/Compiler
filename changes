






  and handle_const e sexpr_list = match e with
    | Nil-> []
    | Vector (elements) -> (List.flatten( List.map (fun (elem )-> handle_const elem sexpr_list) elements))@ [Sexpr(Vector elements)]
    | Pair (first ,second) ->(handle_const first sexpr_list )@(handle_const second sexpr_list)@[ Sexpr (Pair (first ,second))]
    | Bool (b) -> []
    | Symbol (sym) -> [Sexpr (String (sym)); Sexpr (Symbol (sym))]
    | e -> [Sexpr(e)]
   

let rec remove_duplicate original new_list = 
let length = List.length original in
if length = 0 then  new_list
else 
let head = (List.hd original) in
let tail =(List.tl original) in
if List.mem head new_list then remove_duplicate tail new_list 
else  remove_duplicate tail (new_list @ [head]);;




let ascii_string string =
let ascii_code = List.map Char.code (string_to_list string) in 
let ascii_list = List.map (fun(x) -> (string_of_int x )) ascii_code in
let ans = String.concat "," ascii_list in
ans;;






---------------------------------------------------------------------------------------------------------------------------
   | Applic' (proc , arg_list) -> 
          let magic = "
          ; mov r10,SOB_NIL_ADDRESS ; MAGIC PARAM - NULL?
          push SOB_NIL_ADDRESS  
          " in
          let rev = List.rev arg_list in
          let args_text = gen_map rev "\n push rax \n" consts fvars env  previous_arg_number lambda_depth params_so_far in
          let args_and_length = args_text ^ "\n push "^ string_of_int (List.length arg_list)^" \n" in
          let proc_text = generate_handle consts fvars proc env previous_arg_number lambda_depth params_so_far in
          let with_proc = args_and_length ^ proc_text in                
          magic^with_proc^ 
          "\n cmp byte[rax],  T_CLOSURE
          jne invalid           
          CLOSURE_ENV rbx, rax
          push rbx
          CLOSURE_CODE rax, rax 
          call rax \n 
          add rsp, 8*1        ; pop env
          pop rbx             ; pop arg count
          shl rbx, 3          ; rbx = rbx * 8
          add rsp, rbx        ; pop args
          add rsp , 8     
          "  
  
          | ApplicTP'(proc , arg_list) ->
          let magic = "\n;TP \n push qword SOB_NIL_ADDRESS  \n" in
          let rev = List.rev arg_list in
          let args_text = gen_map rev "\n push rax \n" consts fvars env   previous_arg_number lambda_depth params_so_far in
          let post_args = args_text ^ "\n push "^ string_of_int (List.length arg_list)^" \n" in
          let shiftFrameArg = string_of_int ((List.length arg_list)+5) in
          let proc_text = generate_handle consts fvars proc env  previous_arg_number lambda_depth params_so_far in
          let with_proc = post_args ^ proc_text in  
          magic^with_proc ^ 
          "\n cmp byte[rax],  T_CLOSURE
          jne invalid   
          CLOSURE_ENV rbx, rax
          push rbx 
          mov r14, rbp
          add r14, 8
          push qword [r14]
          mov r14, qword [rbp]                       ;;;;;;;;; TP ;;;;;;;;;;;;;;
          mov r8, 3
          shl r8, 3
          add r8, rbp
          mov r9, qword[r8]
          SHIFT_FRAME "^ shiftFrameArg ^   
          "\nadd r9,5
          shl r9, 3     
          add rsp, r9
          mov rbp, r14 \n                            
          CLOSURE_CODE r12, rax 
          jmp r12
          "     
